<button onclick="generateHybridTerrain()">Add Default Terrain</button>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NovaBuilder â€” Game Studio</title>
<style>
body { margin:0; overflow:hidden; font-family:Arial; background:#1a1a1a; color:#eee; }
#topbar { position:fixed; top:0; left:0; width:100%; height:40px; background:#2c2c2c; display:flex; align-items:center; padding:5px 10px; z-index:10; }
#topbar button { margin-right:10px; padding:6px 12px; border:none; background:#444; color:white; border-radius:4px; cursor:pointer; }
#sidebar-left { position:fixed; top:40px; left:0; width:220px; bottom:0; background:#202020; border-right:2px solid #111; overflow-y:auto; padding:5px; }
#sidebar-right { position:fixed; top:40px; right:0; width:260px; bottom:0; background:#202020; border-left:2px solid #111; overflow-y:auto; padding:5px; }
#viewport { position:fixed; top:40px; left:220px; right:260px; bottom:0; background:#111; }
.panel-title { font-weight:bold; margin:10px 0 5px; font-size:16px; }
.panel-section { padding:5px; border-bottom:1px solid #333; }
input, select { width:100%; padding:5px; background:#333; border:1px solid #555; color:white; margin-top:5px; }
</style>
</head>
<body>

<div id="topbar">
  <button onclick="addObject('cube')">Add Cube</button>
  <button onclick="addObject('sphere')">Add Sphere</button>
  <button onclick="generateHybridTerrain()">Add Terrain</button>
  <button id="playBtn" onclick="togglePlay()">Play</button>
</div>

<div id="sidebar-left">
  <div class="panel-title">Workspace</div>
  <div id="hierarchy" class="panel-section"></div>
</div>

<div id="sidebar-right">
  <div class="panel-title">Properties</div>
  <div id="properties" class="panel-section">Select an object</div>
</div>

<div id="viewport"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/TransformControls.js"></script>

<script>
// ========================
// GLOBAL VARIABLES
// ========================
let scene, camera, renderer, orbit, transform;
let selected = null;
let objects = [];
let isPlayMode = false;
let player = null;
let playerVelocity = new THREE.Vector3();
const gravity = -0.5;
let keys = {};

// ========================
// INIT FUNCTION
// ========================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x262626);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(8,8,8);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("viewport").appendChild(renderer.domElement);

    orbit = new THREE.OrbitControls(camera, renderer.domElement);

    transform = new THREE.TransformControls(camera, renderer.domElement);
    transform.addEventListener("dragging-changed", e => orbit.enabled = !e.value);
    scene.add(transform);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10,20,10);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0xffffff,0.3);
    scene.add(ambient);

    // Grid helper
    const grid = new THREE.GridHelper(200,200);
    scene.add(grid);

    animate();
}

// ========================
// ANIMATION LOOP
// ========================
function animate() {
    requestAnimationFrame(animate);

    if(isPlayMode && player){
        // Basic physics
        if(!isGrounded(player)){
            playerVelocity.y += gravity * 0.02;
        } else { playerVelocity.y = Math.max(0, playerVelocity.y); }

        if(keys['w']) player.position.z -= 0.2;
        if(keys['s']) player.position.z += 0.2;
        if(keys['a']) player.position.x -= 0.2;
        if(keys['d']) player.position.x += 0.2;
        if(keys[' ']) playerVelocity.y = 0.5;

        player.position.y += playerVelocity.y;
        camera.position.set(player.position.x+5,player.position.y+5,player.position.z+5);
        camera.lookAt(player.position);
    }

    renderer.render(scene, camera);
}

// ========================
// OBJECT FUNCTIONS
// ========================
let idCounter = 0;
function addObject(type){
    if(isPlayMode) return;
    let mesh;
    if(type==='cube') mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x00aaff}));
    if(type==='sphere') mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6,32,32), new THREE.MeshStandardMaterial({color:0xff6666}));
    mesh.position.set(0,1,0);
    mesh.userData.id = "obj"+(idCounter++);
    mesh.userData.type = type;
    scene.add(mesh);
    objects.push(mesh);
    refreshHierarchy();
}

function refreshHierarchy(){
    let html = '';
    objects.forEach(o => html += `<div onclick="selectObject('${o.userData.id}')">${o.userData.id} (${o.userData.type})</div>`);
    if(scene.getObjectByName('terrain')) html += `<div onclick="selectObject('terrain')">Terrain</div>`;
    document.getElementById("hierarchy").innerHTML = html;
}

function selectObject(id){
    selected = objects.find(o => o.userData.id===id) || scene.getObjectByName(id);
    if(selected) transform.attach(selected);
    updatePropertiesPanel();
}

function updatePropertiesPanel(){
    if(!selected) return;
    document.getElementById("properties").innerHTML = `
        <label>Position X</label><input type="number" value="${selected.position.x}" onchange="selected.position.x=parseFloat(this.value)">
        <label>Position Y</label><input type="number" value="${selected.position.y}" onchange="selected.position.y=parseFloat(this.value)">
        <label>Position Z</label><input type="number" value="${selected.position.z}" onchange="selected.position.z=parseFloat(this.value)">
    `;
}

// ========================
// TERRAIN GENERATOR
// ========================
function generateHybridTerrain(){
    if(isPlayMode) return;
    const size = 200;
    const segments = 200;
    const flatRadius = 40;
    const maxMountainHeight = 25;

    const geometry = new THREE.PlaneGeometry(size,size,segments,segments);
    geometry.rotateX(-Math.PI/2);
    const pos = geometry.attributes.position;

    for(let i=0;i<pos.count;i++){
        let x = pos.getX(i);
        let z = pos.getZ(i);
        const dist = Math.sqrt(x*x+z*z);
        if(dist<flatRadius){ pos.setY(i,0); continue; }
        let factor = (dist-flatRadius)/(size/2-flatRadius);
        factor = Math.min(1,Math.max(0,factor));
        const height = Math.sin(x*0.08)*Math.cos(z*0.08)*8 + Math.sin(x*0.15)*4 + factor*maxMountainHeight;
        pos.setY(i,height);
    }

    pos.needsUpdate = true;
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({color:0x228833, roughness:1});
    const terrain = new THREE.Mesh(geometry,material);
    terrain.receiveShadow = true;
    terrain.name='terrain';
    scene.add(terrain);
    refreshHierarchy();
}

// ========================
// PLAY MODE
// ========================
function togglePlay(){
    isPlayMode = !isPlayMode;
    const btn = document.getElementById('playBtn');
    if(isPlayMode){
        btn.innerText='Stop';
        // Disable editing
        transform.detach();
        // Spawn player
        player = new THREE.Mesh(new THREE.BoxGeometry(1,1.8,1),new THREE.MeshStandardMaterial({color:0xffaa00}));
        player.position.set(0,5,0);
        scene.add(player);
    } else {
        btn.innerText='Play';
        // Remove player
        if(player) scene.remove(player);
        player = null;
    }
}

function isGrounded(obj){
    if(!obj) return false;
    let terrain = scene.getObjectByName('terrain');
    if(!terrain) return obj.position.y<=0;
    const pos = obj.position;
    // approximate ground by terrain height
    const terrainHeight = getTerrainHeight(pos.x,pos.z,terrain);
    return pos.y<=terrainHeight+0.1;
}

function getTerrainHeight(x,z,terrain){
    const geom = terrain.geometry;
    const size = 200;
    const segments = 200;
    const half = size/2;
    const step = size/segments;
    const ix = Math.floor((x+half)/step);
    const iz = Math.floor((z+half)/step);
    const idx = ix + iz*(segments+1);
    if(idx<0 || idx>=geom.attributes.position.count) return 0;
    return geom.attributes.position.getY(idx);
}

// ========================
// INPUT
// ========================
window.addEventListener('keydown', e => keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()]=false);

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

init();
</script>
</body>
</html>
