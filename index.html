<button onclick="generateHybridTerrain()">Add Default Terrain</button>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roblox Studio Knockoff - NovaBuilder</title>
<style>
  /* === Reset & base === */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #181818;
    color: #ddd;
    user-select: none;
  }
  button, select, input[type=color], input[type=number] {
    background: #282828;
    border: 1px solid #444;
    color: #eee;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 13px;
  }
  button:hover, select:hover, input[type=color]:hover, input[type=number]:hover {
    background: #3a3a3a;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #topbar {
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 40px;
    background: #252525;
    display: flex;
    align-items: center;
    padding: 0 10px;
    gap: 8px;
    z-index: 1000;
  }
  #topbar > * {
    height: 28px;
  }
  #sidebar-left, #sidebar-right {
    position: fixed;
    top: 40px;
    bottom: 0;
    background: #212121;
    overflow-y: auto;
    padding: 10px;
    font-size: 14px;
  }
  #sidebar-left {
    left: 0;
    width: 230px;
    border-right: 2px solid #111;
  }
  #sidebar-right {
    right: 0;
    width: 280px;
    border-left: 2px solid #111;
  }
  #viewport {
    position: fixed;
    top: 40px;
    left: 230px;
    right: 280px;
    bottom: 0;
    background: #111;
    overflow: hidden;
  }
  .panel-title {
    font-weight: 700;
    font-size: 16px;
    margin-bottom: 10px;
    border-bottom: 1px solid #444;
    padding-bottom: 6px;
  }
  #hierarchy div {
    padding: 4px 6px;
    border-radius: 3px;
    cursor: pointer;
  }
  #hierarchy div.selected {
    background: #3a81f7;
  }
  #properties label {
    display: block;
    margin-top: 10px;
    font-weight: 600;
  }
  #properties input[type=number], #properties input[type=color], #properties select {
    width: 100%;
    margin-top: 3px;
    color: #eee;
  }
  #terrainMaterial {
    height: 28px;
  }
  #modeIndicator {
    margin-left: auto;
    font-weight: 700;
    font-size: 14px;
    color: #7acaff;
    user-select: none;
  }
</style>
</head>
<body>
  <div id="topbar">
    <button id="btnAddCube" title="Add Cube">Add Cube</button>
    <button id="btnAddSphere" title="Add Sphere">Add Sphere</button>
    <button id="btnAddTerrain" title="Add Hybrid Terrain">Add Terrain</button>
    <select id="terrainMaterial" title="Select Terrain Paint Material" aria-label="Terrain Material">
      <option value="grass">Grass</option>
      <option value="rock">Rock</option>
      <option value="sand">Sand</option>
    </select>
    <input type="color" id="colorPicker" title="Change Object Color" value="#00aaff" aria-label="Object Color Picker" />
    <button id="btnPlay" title="Play/Stop">Play</button>
    <div id="modeIndicator">Edit Mode</div>
  </div>
  <div id="sidebar-left">
    <div class="panel-title">Workspace</div>
    <div id="hierarchy" role="tree" tabindex="0" aria-label="Hierarchy Panel"></div>
  </div>
  <div id="sidebar-right">
    <div class="panel-title">Properties</div>
    <div id="properties">Select an object</div>
  </div>
  <div id="viewport" tabindex="0" aria-label="3D Viewport"></div>

  <!-- Three.js & Controls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/TransformControls.js"></script>

  <script>
  (() => {
    // === Globals ===
    let scene, camera, renderer, orbit, transform;
    let selected = null;
    let objects = [];
    let terrain = null;
    let isPlayMode = false;
    let player = null;
    let playerVelocity = new THREE.Vector3();
    let keys = {};
    let terrainMaterial = 'grass';
    const terrainMaterials = {
      grass: 0x228833,
      rock: 0x888888,
      sand: 0xffdd99
    };

    const viewport = document.getElementById('viewport');
    const hierarchy = document.getElementById('hierarchy');
    const properties = document.getElementById('properties');
    const btnAddCube = document.getElementById('btnAddCube');
    const btnAddSphere = document.getElementById('btnAddSphere');
    const btnAddTerrain = document.getElementById('btnAddTerrain');
    const btnPlay = document.getElementById('btnPlay');
    const terrainMaterialSelect = document.getElementById('terrainMaterial');
    const colorPicker = document.getElementById('colorPicker');
    const modeIndicator = document.getElementById('modeIndicator');

    let idCounter = 0;

    // === Initialization ===
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x262626);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 500);
      camera.position.set(10, 10, 10);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(viewport.clientWidth, viewport.clientHeight);
      viewport.appendChild(renderer.domElement);

      orbit = new THREE.OrbitControls(camera, renderer.domElement);
      orbit.enableDamping = true;
      orbit.dampingFactor = 0.05;

      transform = new THREE.TransformControls(camera, renderer.domElement);
      transform.addEventListener('dragging-changed', (event) => {
        orbit.enabled = !event.value;
        updatePropertiesPanel();
      });
      transform.addEventListener('objectChange', () => {
        updatePropertiesPanel();
        refreshHierarchy();
      });
      scene.add(transform);

      // Lights
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));

      // Grid Helper
      const grid = new THREE.GridHelper(200, 200, 0x666666, 0x333333);
      scene.add(grid);

      // Event Listeners
      window.addEventListener('resize', onWindowResize);
      viewport.addEventListener('click', onViewportClick);

      btnAddCube.addEventListener('click', () => addObject('cube'));
      btnAddSphere.addEventListener('click', () => addObject('sphere'));
      btnAddTerrain.addEventListener('click', () => generateHybridTerrain());
      btnPlay.addEventListener('click', togglePlay);
      terrainMaterialSelect.addEventListener('change', (e) => {
        terrainMaterial = e.target.value;
        if (terrain) {
          terrain.material.color.setHex(terrainMaterials[terrainMaterial]);
        }
      });
      colorPicker.addEventListener('input', (e) => {
        if (selected && selected !== terrain) {
          selected.material.color.set(e.target.value);
          updatePropertiesPanel();
        }
      });
      hierarchy.addEventListener('click', (e) => {
        if (e.target && e.target.dataset.id) {
          selectObjectById(e.target.dataset.id);
        }
      });

      // Keyboard controls for play mode
      window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
      window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

      animate();
    }

    // === Animation Loop ===
    function animate() {
      requestAnimationFrame(animate);

      if (isPlayMode && player) {
        updatePlayerPhysics();
      }
      orbit.update();
      renderer.render(scene, camera);
    }

    // === Window Resize ===
    function onWindowResize() {
      const w = viewport.clientWidth;
      const h = viewport.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    // === Add Objects ===
    function addObject(type) {
      if (isPlayMode) return;
      let mesh;
      if (type === 'cube') {
        mesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({ color: 0x00aaff })
        );
      } else if (type === 'sphere') {
        mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.6, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xff6666 })
        );
      }
      mesh.position.set(0, 1, 0);
      mesh.userData.id = `obj${idCounter++}`;
      mesh.userData.type = type;
      scene.add(mesh);
      objects.push(mesh);
      selectObject(mesh);
      refreshHierarchy();
    }

    // === Generate Hybrid Terrain ===
    function generateHybridTerrain() {
      if (isPlayMode) return;
      if (terrain) {
        scene.remove(terrain);
        terrain.geometry.dispose();
        terrain.material.dispose();
        terrain = null;
      }
      const size = 200, segments = 200, flatRadius = 40, maxHeight = 25;
      const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
      geometry.rotateX(-Math.PI / 2);
      const pos = geometry.attributes.position;

      for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i), z = pos.getZ(i);
        const dist = Math.sqrt(x * x + z * z);
        if (dist < flatRadius) {
          pos.setY(i, 0);
          continue;
        }
        let factor = (dist - flatRadius) / (size / 2 - flatRadius);
        factor = Math.min(1, Math.max(0, factor));
        const height =
          Math.sin(x * 0.08) * Math.cos(z * 0.08) * 8 +
          Math.sin(x * 0.15) * 4 +
          factor * maxHeight;
        pos.setY(i, height);
      }
      pos.needsUpdate = true;
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        color: terrainMaterials[terrainMaterial],
        roughness: 1,
      });
      terrain = new THREE.Mesh(geometry, material);
      terrain.receiveShadow = true;
      terrain.userData.id = 'terrain';
      scene.add(terrain);
      selectObject(terrain);
      refreshHierarchy();
    }

    // === Refresh Hierarchy Panel ===
    function refreshHierarchy() {
      let html = '';
      if (terrain) html += `<div data-id="terrain" class="${selected === terrain ? 'selected' : ''}">Terrain</div>`;
      objects.forEach((obj) => {
        html += `<div data-id="${obj.userData.id}" class="${selected === obj ? 'selected' : ''}">
          ${obj.userData.id} (${obj.userData.type})
        </div>`;
      });
      hierarchy.innerHTML = html;
    }

    // === Select Object by Id ===
    function selectObjectById(id) {
      if (id === 'terrain') {
        selectObject(terrain);
      } else {
        const obj = objects.find((o) => o.userData.id === id);
        if (obj) selectObject(obj);
      }
    }

    // === Select Object ===
    function selectObject(obj) {
      if (isPlayMode) return;
      selected = obj;
      transform.attach(selected);
      updatePropertiesPanel();
      refreshHierarchy();
      // Update color picker
      if (selected && selected.material && selected.material.color) {
        colorPicker.value = '#' + selected.material.color.getHexString();
      }
    }

    // === Update Properties Panel ===
    function updatePropertiesPanel() {
      if (!selected) {
        properties.innerHTML = 'Select an object';
        return;
      }
      const pos = selected.position;
      const rot = selected.rotation;
      const scale = selected.scale;

      // Compose HTML for properties
      properties.innerHTML = `
        <label for="posX">Position X</label>
        <input type="number" id="posX" step="0.1" value="${pos.x.toFixed(2)}" />
        <label for="posY">Position Y</label>
        <input type="number" id="posY" step="0.1" value="${pos.y.toFixed(2)}" />
        <label for="posZ">Position Z</label>
        <input type="number" id="posZ" step="0.1" value="${pos.z.toFixed(2)}" />
        
        <label for="rotX">Rotation X</label>
        <input type="number" id="rotX" step="0.1" value="${THREE.MathUtils.radToDeg(rot.x).toFixed(1)}" />
        <label for="rotY">Rotation Y</label>
        <input type="number" id="rotY" step="0.1" value="${THREE.MathUtils.radToDeg(rot.y).toFixed(1)}" />
        <label for="rotZ">Rotation Z</label>
        <input type="number" id="rotZ" step="0.1" value="${THREE.MathUtils.radToDeg(rot.z).toFixed(1)}" />
        
        <label for="scaleX">Scale X</label>
        <input type="number" id="scaleX" step="0.1" min="0.1" value="${scale.x.toFixed(2)}" />
        <label for="scaleY">Scale Y</label>
        <input type="number" id="scaleY" step="0.1" min="0.1" value="${scale.y.toFixed(2)}" />
        <label for="scaleZ">Scale Z</label>
        <input type="number" id="scaleZ" step="0.1" min="0.1" value="${scale.z.toFixed(2)}" />
      `;

      // Attach event listeners for inputs
      ['posX', 'posY', 'posZ'].forEach((id) => {
        document.getElementById(id).oninput = (e) => {
          selected.position[id[3].toLowerCase()] = parseFloat(e.target.value);
          refreshHierarchy();
        };
      });
      ['rotX', 'rotY', 'rotZ'].forEach((id) => {
        document.getElementById(id).oninput = (e) => {
          const deg = parseFloat(e.target.value);
          if (!isNaN(deg)) {
            selected.rotation[id[3].toLowerCase()] = THREE.MathUtils.degToRad(deg);
            refreshHierarchy();
          }
        };
      });
      ['scaleX', 'scaleY', 'scaleZ'].forEach((id) => {
        document.getElementById(id).oninput = (e) => {
          const val = parseFloat(e.target.value);
          if (val > 0) {
            selected.scale[id[5].toLowerCase()] = val;
            refreshHierarchy();
          }
        };
      });
    }

    // === Play Mode Toggle ===
    function togglePlay() {
      if (!isPlayMode) {
        enterPlayMode();
      } else {
        exitPlayMode();
      }
    }

    // === Enter Play Mode ===
    function enterPlayMode() {
      if (isPlayMode) return;
      if (!terrain) {
        alert('Please add terrain before playing.');
        return;
      }
      isPlayMode = true;
      modeIndicator.textContent = 'Play Mode';
      btnPlay.textContent = 'Stop';

      // Detach transform gizmo
      transform.detach();

      // Disable UI buttons except Stop
      btnAddCube.disabled = true;
      btnAddSphere.disabled = true;
      btnAddTerrain.disabled = true;
      terrainMaterialSelect.disabled = true;
      colorPicker.disabled = true;

      // Spawn player cube
      player = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1.8, 1),
        new THREE.MeshStandardMaterial({ color: 0xffaa00 })
      );
      player.position.set(0, 5, 0);
      scene.add(player);

      // Set camera behind player
      camera.position.set(player.position.x + 5, player.position.y + 5, player.position.z + 5);
      camera.lookAt(player.position);

      // Disable orbit controls (mouse)
      orbit.enabled = false;

      // Remove selection highlight
      selected = null;
      refreshHierarchy();
      updatePropertiesPanel();
    }

    // === Exit Play Mode ===
    function exitPlayMode() {
      if (!isPlayMode
