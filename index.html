<button onclick="generateHybridTerrain()">Add Default Terrain</button>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NovaBuilder - Roblox Studio Knockoff</title>
<style>
body { margin:0; overflow:hidden; font-family:Arial; background:#1e1e1e; color:#eee; }
#topbar { position:fixed; top:0; left:0; width:100%; height:40px; background:#2a2a2a; display:flex; align-items:center; padding:5px 10px; z-index:10; }
#topbar button, #topbar select { margin-right:10px; padding:6px 12px; border:none; background:#444; color:white; border-radius:4px; cursor:pointer; }
#sidebar-left { position:fixed; top:40px; left:0; width:220px; bottom:0; background:#202020; border-right:2px solid #111; overflow-y:auto; padding:5px; }
#sidebar-right { position:fixed; top:40px; right:0; width:260px; bottom:0; background:#202020; border-left:2px solid #111; overflow-y:auto; padding:5px; }
#viewport { position:fixed; top:40px; left:220px; right:260px; bottom:0; background:#111; }
.panel-title { font-weight:bold; margin:10px 0 5px; font-size:16px; }
.panel-section { padding:5px; border-bottom:1px solid #333; }
input, select { width:100%; padding:5px; background:#333; border:1px solid #555; color:white; margin-top:5px; }
</style>
</head>
<body>

<div id="topbar">
  <button onclick="addObject('cube')">Add Cube</button>
  <button onclick="addObject('sphere')">Add Sphere</button>
  <button onclick="generateHybridTerrain()">Add Terrain</button>
  <select id="terrainPaint" onchange="selectTerrainMaterial(this.value)">
    <option value="0x228833">Grass</option>
    <option value="0x888888">Rock</option>
    <option value="0xffdd99">Sand</option>
  </select>
  <input type="color" id="objColor" value="#00aaff" onchange="changeObjectColor(this.value)">
  <button id="playBtn" onclick="togglePlay()">Play</button>
</div>

<div id="sidebar-left">
  <div class="panel-title">Workspace</div>
  <div id="hierarchy" class="panel-section"></div>
</div>

<div id="sidebar-right">
  <div class="panel-title">Properties</div>
  <div id="properties" class="panel-section">Select an object</div>
</div>

<div id="viewport"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159/examples/js/controls/TransformControls.js"></script>

<script>
// ========================
// GLOBALS
// ========================
let scene, camera, renderer, orbit, transform;
let selected = null, objects = [], terrain = null;
let isPlayMode = false, player = null, playerVelocity = new THREE.Vector3();
let keys = {};
let terrainMaterialColor = 0x228833;

// ========================
// INIT
// ========================
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x262626);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(8,8,8);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("viewport").appendChild(renderer.domElement);

    orbit = new THREE.OrbitControls(camera, renderer.domElement);

    transform = new THREE.TransformControls(camera, renderer.domElement);
    transform.addEventListener("dragging-changed", e => orbit.enabled = !e.value);
    scene.add(transform);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10,20,10);
    scene.add(light);

    scene.add(new THREE.AmbientLight(0xffffff,0.3));

    scene.add(new THREE.GridHelper(200,200));

    animate();
}

// ========================
// ANIMATE
// ========================
function animate() {
    requestAnimationFrame(animate);

    if(isPlayMode && player){
        if(!isGrounded(player)){
            playerVelocity.y += -0.5*0.02;
        } else { playerVelocity.y = Math.max(0, playerVelocity.y); }

        if(keys['w']) player.position.z -= 0.2;
        if(keys['s']) player.position.z += 0.2;
        if(keys['a']) player.position.x -= 0.2;
        if(keys['d']) player.position.x += 0.2;
        if(keys[' ']) playerVelocity.y = 0.5;

        player.position.y += playerVelocity.y;
        camera.position.set(player.position.x+5,player.position.y+5,player.position.z+5);
        camera.lookAt(player.position);
    }

    renderer.render(scene, camera);
}

// ========================
// OBJECTS
// ========================
let idCounter = 0;
function addObject(type){
    if(isPlayMode) return;
    let mesh;
    if(type==='cube') mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0x00aaff}));
    if(type==='sphere') mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6,32,32), new THREE.MeshStandardMaterial({color:0xff6666}));
    mesh.position.set(0,1,0);
    mesh.userData.id = "obj"+(idCounter++);
    mesh.userData.type = type;
    scene.add(mesh);
    objects.push(mesh);
    refreshHierarchy();
}

function refreshHierarchy(){
    let html = '';
    objects.forEach(o => html += `<div onclick="selectObject('${o.userData.id}')">${o.userData.id} (${o.userData.type})</div>`);
    if(terrain) html += `<div onclick="selectObject('terrain')">Terrain</div>`;
    document.getElementById("hierarchy").innerHTML = html;
}

function selectObject(id){
    if(id==='terrain') selected = terrain;
    else selected = objects.find(o=>o.userData.id===id);
    if(selected) transform.attach(selected);
    updatePropertiesPanel();
}

function updatePropertiesPanel(){
    if(!selected) return;
    document.getElementById("properties").innerHTML = `
        <label>Position X</label><input type="number" value="${selected.position.x}" onchange="selected.position.x=parseFloat(this.value)">
        <label>Position Y</label><input type="number" value="${selected.position.y}" onchange="selected.position.y=parseFloat(this.value)">
        <label>Position Z</label><input type="number" value="${selected.position.z}" onchange="selected.position.z=parseFloat(this.value)">
    `;
}

function changeObjectColor(color){
    if(selected && selected!==terrain){
        selected.material.color.set(color);
    }
}

// ========================
// TERRAIN
// ========================
function generateHybridTerrain(){
    if(isPlayMode) return;
    const size = 200, segments=200, flatRadius=40, maxHeight=25;
    const geometry = new THREE.PlaneGeometry(size,size,segments,segments);
    geometry.rotateX(-Math.PI/2);
    const pos = geometry.attributes.position;

    for(let i=0;i<pos.count;i++){
        let x = pos.getX(i), z=pos.getZ(i);
        const dist = Math.sqrt(x*x+z*z);
        if(dist<flatRadius){ pos.setY(i,0); continue; }
        let factor=(dist-flatRadius)/(size/2-flatRadius);
        factor=Math.min(1,Math.max(0,factor));
        const height = Math.sin(x*0.08)*Math.cos(z*0.08)*8 + Math.sin(x*0.15)*4 + factor*maxHeight;
        pos.setY(i,height);
    }
    pos.needsUpdate = true;
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({color:terrainMaterialColor, roughness:1});
    terrain = new THREE.Mesh(geometry, material);
    terrain.receiveShadow = true;
    terrain.name='terrain';
    scene.add(terrain);
    refreshHierarchy();
}

function selectTerrainMaterial(color){
    terrainMaterialColor = parseInt(color);
    if(terrain) terrain.material.color.set(color);
}

// ========================
// PLAY MODE
// ========================
function togglePlay(){
    isPlayMode = !isPlayMode;
    const btn = document.getElementById('playBtn');
    if(isPlayMode){
        btn.innerText='Stop';
        transform.detach();
        player = new THREE.Mesh(new THREE.BoxGeometry(1,1.8,1), new THREE.MeshStandardMaterial({color:0xffaa00}));
        player.position.set(0,5,0);
        scene.add(player);
    } else {
        btn.innerText='Play';
        if(player) scene.remove(player);
        player=null;
    }
}

function isGrounded(obj){
    if(!obj) return false;
    if(!terrain) return obj.position.y<=0;
    return obj.position.y<=getTerrainHeight(obj.position.x,obj.position.z)+0.1;
}

function getTerrainHeight(x,z,terrain){
    const geom=terrain.geometry, size=200, segments=200, half=size/2, step=size/segments;
    const ix = Math.floor((x+half)/step);
    const iz = Math.floor((z+half)/step);
    const idx = ix + iz*(segments+1);
    if(idx<0||idx>=geom.attributes.position.count) return 0;
    return geom.attributes.position.getY(idx);
}

// ========================
// INPUT
// ========================
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

init();
</script>
</body>
</html>
